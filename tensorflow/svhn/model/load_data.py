# Import Modules
from six.moves import cPickle as pickle
from six.moves import range
from six.moves.urllib.request import urlretrieve
from PIL import Image
import numpy as np
import os
import sys
import tarfile
import h5py
from numpy import random

# Download data
print('Downloading data...')

url = 'http://ufldl.stanford.edu/housenumbers/'
root = '/Users/zpwu/Downloads/'


def maybe_download(filename, force=False):
    """Download a file if not present"""
    filename = os.path.join(root, filename)
    if force or not os.path.exists(filename):
        print('Attempting to download:', filename)
        filename, _ = urlretrieve(url + filename, filename)
        print('Download Complete!')
    return filename


train_filename = maybe_download('train.tar.gz')
test_filename = maybe_download('test.tar.gz')
extra_filename = maybe_download('extra.tar.gz')

print('Successfully downloaded data!')

# Unzip Data
print('Unzipping data...')
np.random.seed(8)


def maybe_extract(filename, force=False):
    # Remove .tar.gz
    root = os.path.splitext(os.path.splitext(filename)[0])[0]
    if os.path.isdir(root) and not force:
        # You may override by setting force=True.
        print('%s already present - Skipping extraction of %s.' % (root, filename))
    else:
        print('Extracting data for %s. This may take a while. Please wait.' % root)
        tar = tarfile.open(filename)
        sys.stdout.flush()
        tar.extractall()
        tar.close()
    data_folders = root
    print(data_folders)
    return data_folders


train_folders = maybe_extract(train_filename)
test_folders = maybe_extract(test_filename)
extra_folders = maybe_extract(extra_filename)

print('Successfully unzipped data!')

# Create dictionary for bounding boxes
print('Creating dictionary of bounding boxes...')


class DigitStructFile:
    def __init__(self, inf):
        self.inf = h5py.File(inf, 'r')
        self.digitStructName = self.inf['digitStruct']['name']
        self.digitStructBbox = self.inf['digitStruct']['bbox']

    def getName(self, n):
        return ''.join([chr(c[0]) for c in self.inf[self.digitStructName[n][0]].value])

    def bboxHelper(self, attr):
        if (len(attr) > 1):
            attr = [self.inf[attr.value[j].item()].value[0][0] for j in range(len(attr))]
        else:
            attr = [attr.value[0][0]]
        return attr

    def getBbox(self, n):
        bbox = {}
        bb = self.digitStructBbox[n].item()
        bbox['height'] = self.bboxHelper(self.inf[bb]["height"])
        bbox['label'] = self.bboxHelper(self.inf[bb]["label"])
        bbox['left'] = self.bboxHelper(self.inf[bb]["left"])
        bbox['top'] = self.bboxHelper(self.inf[bb]["top"])
        bbox['width'] = self.bboxHelper(self.inf[bb]["width"])
        return bbox

    def getDigitStructure(self, n):
        '''
        S: {
            'height': [219.0, 219.0],
            'label': [1.0, 9.0],
            'left': [246.0, 323.0],
            'top': [77.0, 81.0],
            'width': [81.0, 96.0],
            'name': '1.png'}
        '''
        s = self.getBbox(n)
        s['name'] = self.getName(n)
        return s

    def transform_box(self, pictDat):
        '''
        item:  {
            'filename': '1.png',
            'boxes': [
                {'height': 219.0, 'left': 246.0, 'label': 1.0, 'top': 77.0, 'width': 81.0},
                {'height': 219.0, 'left': 323.0, 'label': 9.0, 'top': 81.0, 'width': 96.0},
                ]
            }
        '''
        item = {'filename': pictDat["name"]}
        figures = []
        for j in range(len(pictDat['height'])):
            figure = {}
            figure['height'] = pictDat['height'][j]
            figure['label'] = pictDat['label'][j]
            figure['left'] = pictDat['left'][j]
            figure['top'] = pictDat['top'][j]
            figure['width'] = pictDat['width'][j]
            figures.append(figure)
        item['boxes'] = figures
        return item

    def getAllDigitStructure(self):
        return [self.getDigitStructure(i) for i in range(len(self.digitStructName))]

    def getAllDigitStructure_ByDigit(self):
        pictDat = self.getAllDigitStructure()
        result = []
        for i in range(len(pictDat)):
            item = self.transform_box(pictDat[i])
            result.append(item)
        return result


print("Successfully created dictionary of bounding boxes!")

# Get Digit Structure
print('Getting digit structure for training data...')
digitFileTrain=DigitStructFile(os.path.join(train_folders,'digitStruct.mat'))
train_data = digitFileTrain.getAllDigitStructure_ByDigit()
print('Success!')

print('Getting digit structure for test data...')
digitFileTest=DigitStructFile(os.path.join(test_folders,'digitStruct.mat'))
test_data = digitFileTest.getAllDigitStructure_ByDigit()
print('Success!')

print('Getting digit structure for extra data...')
digitFileExtra=DigitStructFile(os.path.join(extra_folders,'digitStruct.mat'))
extra_data = digitFileExtra.getAllDigitStructure_ByDigit()
print('Success!')

# def get_image_data(data, images_folders):
#     '''
#     imsize N X width x height
#     '''
#     imsize = np.ndarray([len(data), 2])
#     for i in np.arange(len(data)):
#         filename = data[i]['filename']
#         fullname = os.path.join(images_folders, filename)
#         im = Image.open(fullname)
#         imsize[i, :] = im.size[:]
#     return imsize

# Crop Training Images
# print('Cropping training images...')
# train_imsize = get_image_data(train_data, train_folders)
# print('Success!')

# Crop Test Images
# print('Cropping test images...')
# test_imsize = get_image_data(test_data, test_folders)
# print('Success!')

# Crop Extra Images
# print('Cropping extra images...')
# extra_imsize = get_image_data(extra_data, extra_folders)
# print('Success!')


# Use extra data
def generate_dataset(data, folder):
    '''
    item:  {
        'filename': '1.png',
        'boxes': [
            {'height': 219.0, 'left': 246.0, 'label': 1.0, 'top': 77.0, 'width': 81.0},
            {'height': 219.0, 'left': 323.0, 'label': 9.0, 'top': 81.0, 'width': 96.0},
            ]
        }
    '''
    dataset = np.ndarray([len(data), 32, 32, 1], dtype='float32')
    labels = np.ones([len(data), 6], dtype=int) * 10
    for i in np.arange(len(data)):
        filename = data[i]['filename']
        fullname = os.path.join(folder, filename)
        im = Image.open(fullname)
        boxes = data[i]['boxes']
        num_digit = len(boxes)
        labels[i, 0] = num_digit # set number length
        top = np.ndarray([num_digit], dtype='float32')
        left = np.ndarray([num_digit], dtype='float32')
        height = np.ndarray([num_digit], dtype='float32')
        width = np.ndarray([num_digit], dtype='float32')
        for j in np.arange(num_digit):
            if j < 5: # set label for per number
                labels[i, j + 1] = boxes[j]['label']
                if boxes[j]['label'] == 10: labels[i, j + 1] = 0
            else:
                print('#', i, 'image has more than 5 digits.')
            top[j] = boxes[j]['top']
            left[j] = boxes[j]['left']
            height[j] = boxes[j]['height']
            width[j] = boxes[j]['width']

        im_top = np.amin(top)
        im_left = np.amin(left)
        im_height = np.amax(top) + height[np.argmax(top)] - im_top
        im_width = np.amax(left) + width[np.argmax(left)] - im_left

        im_top = np.floor(im_top - 0.1 * im_height)
        im_left = np.floor(im_left - 0.1 * im_width)
        im_bottom = np.amin([np.ceil(im_top + 1.2 * im_height), im.size[1]])
        im_right = np.amin([np.ceil(im_left + 1.2 * im_width), im.size[0]])

        im = im.crop((im_left, im_top, im_right, im_bottom)).resize([32, 32], Image.ANTIALIAS)
        im = np.dot(np.array(im, dtype='float32'), [[0.2989], [0.5870], [0.1140]])
        mean = np.mean(im, dtype='float32')
        std = np.std(im, dtype='float32', ddof=1)
        if std < 1e-4: std = 1.
        im = (im - mean) / std #normalize
        dataset[i, :, :, :] = im[:, :, :]

    return dataset, labels


print('Generating training dataset and labels...')
train_dataset, train_labels = generate_dataset(train_data, train_folders)
print('Success! \n Training set: {} \n Training labels: {}'.format(train_dataset.shape, train_labels.shape))

print('Generating testing dataset and labels...')
test_dataset, test_labels = generate_dataset(test_data, test_folders)
print('Success! \n Testing set: {} \n Testing labels: {}'.format(test_dataset.shape, test_labels.shape))

print('Generating extra dataset and labels...')
extra_dataset, extra_labels = generate_dataset(extra_data, extra_folders)
print('Success! \n Testing set: {} \n Testing labels: {}'.format(extra_dataset.shape, extra_labels.shape))

# Clean up data by deleting digits more than 5 (the label of 29930.png is 135456)
print('Cleaning up training data...')
train_dataset = np.delete(train_dataset, 29929, axis=0)
train_labels = np.delete(train_labels, 29929, axis=0)
print('Success!')

# Expand Training Data
print('Expanding training data randomly...')

random.seed(8)

n_labels = 10
valid_index = []
valid_index2 = []
train_index = []
train_index2 = []
for i in np.arange(n_labels):
    valid_index.extend(np.where(train_labels[:, 1] == (i))[0][:400].tolist())
    train_index.extend(np.where(train_labels[:, 1] == (i))[0][400:].tolist())
    valid_index2.extend(np.where(extra_labels[:, 1] == (i))[0][:200].tolist())
    train_index2.extend(np.where(extra_labels[:, 1] == (i))[0][200:].tolist())

random.shuffle(valid_index)
random.shuffle(train_index)
random.shuffle(valid_index2)
random.shuffle(train_index2)

valid_dataset = np.concatenate((extra_dataset[valid_index2, :, :, :], train_dataset[valid_index, :, :, :]), axis=0)
valid_labels = np.concatenate((extra_labels[valid_index2, :], train_labels[valid_index, :]), axis=0)
train_dataset_new = np.concatenate((extra_dataset[train_index2, :, :, :], train_dataset[train_index, :, :, :]), axis=0)
train_labels_new = np.concatenate((extra_labels[train_index2, :], train_labels[train_index, :]), axis=0)

print('Success! \n Training set: {} \n Training labels: {}'.format(train_dataset_new.shape, train_labels_new.shape))
print('Success! \n Validation set: {} \n Validation labels: {}'.format(valid_dataset.shape, valid_labels.shape))
print('Success! \n Testing set: {} \n Testing labels: {}'.format(test_dataset.shape, test_labels.shape))

# Create Pickling File
print('Pickling data...')
pickle_file = 'SVHN.pickle'

try:
    f = open(pickle_file, 'wb')
    save = {
        'train_dataset': train_dataset_new,
        'train_labels': train_labels_new,
        'valid_dataset': valid_dataset,
        'valid_labels': valid_labels,
        'test_dataset': test_dataset,
        'test_labels': test_labels,
    }
    pickle.dump(save, f, pickle.HIGHEST_PROTOCOL)
    f.close()
except Exception as e:
    print('Unable to save data to {}: {}'.format(pickle_file, e))
    raise

statinfo = os.stat(pickle_file)
print('Success!')
print('Compressed pickle size: {}'.format(statinfo.st_size))
